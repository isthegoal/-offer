# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精


'''
     题目：给定一个二叉树和其中的一个结点k，请找出中序遍历顺序的下一个结点并且返回。

             注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

     分析：这里首先当然最简单的方法是  在中序遍历的过程中，进行发现，当发现结点k时，下一个那么其下一个中序遍历的结果
     就是我们所需要的，但是这个方法 显然不是我们需要的，毕竟时间复杂度太大了，进行了很多无效的遍历。

     这里的思路是从 当前结点k本身出发，考虑会出现三种情况，进行处理[这种比较理智和高效]：
       （1）二叉树为空，则返回空；
       （2）节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为
         下一个节点；
       （3）当右孩子没有时，如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，
         重复之前的判断，返回结果。

'''

def get_next(pNode):
    #第一种情况
    if not pNode:
        return None

    #第二种情况 当右结点存在时，  我们找到其右孩子的最左边作为下一个地点
    if pNode.right:
        pNode=pNode.right
        #走到右孩子中的最左边
        while pNode.left:
            pNode=pNode.left
        return pNode

    #第三种情况 时，当前结点无右子树，则需要找到一个是它父结点的左子树结点的结点
    else:
        while pNode.next:
            # 如果当前结点位于其  父亲的 左结点时，则其下一个就是其父亲
            if pNode==pNode.next.left:
                return pNode.next

            #否则就继续往上找，反正 能够找到  其位于左侧，而 能够利用下一结点作为中间的 结点......
            pNode=pNode.next

    return None
