# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精  【但是有些题就是技巧，先看下方法，别死想】

'''
      题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。

      分析：这里很明显最简单的方法 就是  逐个数去做统计，  但是那样是非常耗时且 非常不现实的。

           因此我们需要从 整数位数出现的本身性质规律出发，进行思路，基本最正确的思考是按位数分别进行思考，从低位到高位，以534为例：
                【1】先考虑个位，个位数出现的次数是    53+1，  这里以53看做round值，  因为最后一位大于0，所以再多加一个即可
                【2】对于十位数数，有个典型的特点是  十位上的数是有延迟的，每增加10，十位上的1出现次数才会加1， 所以次数的统计跟以往的不太一样，是
                          （5+1）*10 =60    这里以百位为5,十位余位大于1，所以当做10吧。

                【3】对于更高位，其实跟十位的计算方式是一样的，应该是
                          （1）*100   因为更上一位没了，而其值大于1.  如果等于1，那就是直接是后面位的值吧

      思路：代码实现的话，我们将n的各位数  分为两类：  个位和其他位
       每一位的权值为base，位值为weight，该位之前的数是former   前面的次数是round
                                                                                      514为例
          【1】对于个位数而言，  如果 个位大于0，则1出现次数为   round*1+1                    51*1+1
                               如果 个位等于0，则1出现次数为   round*1
          【2】对于其他位，     如果  weight为0，则 1出现次数为  round* base
                              如果  weight为1，则 1出现次数为  round* base+former+1         5*10+4+1[十位]
                              如果  weight大于1，则 1出现次数为  round* base+base           0*100+100[百位]

       该方法  while循环的次数就是n的位数,logn（以10为底），而循环体内执行的操作都是有限次的，所以时间复杂度为O(logn)。
'''

def  fun2(n):

    #指定  临界条件
    if n<1:
        return 0

    #创建三个之前  计算式中使用的变量
    count=0  #对所有1出现次数的统计量
    base=1   #base不断变换的，在个位是1，十位是10，百位是1000
    round=n  #round是位数之前的数。    514看个位数时就是51


    #现在从低位到高位开始做统计
    while round>0:
        weight=round%10  #当前位数值的情况， 主要根据这个做判断，很重要

        round=round/10

        #对三种情况的综合  使用，  当前位数下，为0，为1，大于1 三种情况的考虑，我们将  为1和大于作为在0基础上计算的附加。  个位数是没有影响的。
        #以下是对于所有位数核心的统计的公式
        count+=round*base
        if weight==1:
            count+=(n%base)+1
        elif weight>1:
            count+=base

        #对base做更新上
        base*=10

    return count



