# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
     题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

     分析：注意这其中有个关键点，是有两个数字只出现一次，而不是只有一个数值只出现一次【只出现一次方法简单的多】。

        （1）这里回顾下如果找 只有一个数值出现一次的问题，可以使用位运算，这是因为如下的原因：
            比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）
            进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，
            0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。

        （2）而对于当前的情况， 思路也是非常巧妙的，利用了上面的性质。
        方法是：按位异或，在得到的值中找到二进制最后一个1，然后把数组按照该位是0还是1分为两组
        这里为什么这样做呢，因为经过不断异或后，其实就相当于得到  两个只出现一次数 异或处理后的结果，这里对结果观察，可以发现其中结果二进制中为1的
        地方可以表示的是 这两个数对应在二进制上不相同数字的地方【非常重要的点】，然后根据这一性质就可以将原数组分为两个部分。 在这个位上为0为一个数组。
        在这个位上为1是一个数组。   得到两个数组再各自做（1）中处理即可。

        举例：{2,4,3,6,3,2,5,5}
        我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是
        不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来
        只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。
        https://cuijiahua.com/blog/2018/01/basis_40.html

     思路：因为这里要求了空间复杂度的限制，所以不能使用哈希表，而这种 其他数字都出现两次，很明显透露了位运算的讯号。思路就是（2）中的方法，分为两大步
                数组按特殊位拆分两部分  、   两部分各自找目标数

'''



def main(nums):
    #边缘判断
    if not nums:
        return None

    # 或者所有数  初步的所有异或结果  tmp_ret
    tmp_ret=0
    for n in nums:
        tmp_ret^=n

    #针对  结果  计算找到第一个为 1 的 二进制位置   索引号
    last_ont=get_bin(tmp_ret)

    #按照特点，如果  第last_ont位置为1则属于第一个数组，如果不为1为第二个数组。      同时进行异或上的统计
    a_ret,b_ret=0,0
    for n in nums:
        if is_one(n,last_ont):
            a_ret^=n
        else:
            b_ret^=n

    #分别获取两个数组抽取出来的数
    return [a_ret,b_ret]


#获取第一步的索引位置
def get_bin(tmp_ret):
    ret=0
    #这就是找啊 找，   看正数第一位先为1
    while tmp_ret&1==0 and ret>32:  #ret为32是什么原因
        tmp_ret=tmp_ret>>1  #进行不但右移，当只有一个1时，说明右边位都移动光了
        ret+=1

    return ret


#第二步的   判断数的二进制的  特定位数是否为1
def is_one(num,t):
    num=num>>t
    return num & 0x01  #0x01是什么意思呢





