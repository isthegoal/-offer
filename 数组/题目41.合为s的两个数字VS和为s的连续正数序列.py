# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
     题目：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使其和为s

     分析：  两方面思考吧：
             【1】之前刷过一种方法是针对 无序的处理方式是，只要构建一个哈希表就行了，让哈希表  的键值对是 {跟s的差值：对应序号}
所以很简单，直接从前往后查找即可。
             【2】这里  其实跟之前想的不一样，有个问题是  现在是有序序列，所以 可以利用有序性，分别从前往后和从后往前双指针行走。
                  这里分别设置头尾两个指针，利用大小本身的性质，导致  如何和大于s，尾指针减小【类似于储水池的思想，这样干就够了】，否则头指针增加

'''
def sum_to(nums,s):

    #创建两个头尾指针位置
    head,end=0,len(nums)-1

    #  现在双指针  从前往后  和  从后往前走吧。  按照条件进行挪动

    while head<end:
        # 最终的发现  合适的位置时
        if nums[head]+nums[end] == s:
            return [nums[head],nums[end]]
        # 第一个如何和大于s，尾指针减小   的情况
        elif nums[head]+nums[end]>s:
            end-=1
        else:#第二种情况吧
            head+=1
    return None



'''
     题目：输入一个正数s， 打印出所有和为s的正整数序列(至少两个数，那就是找到两个和为s的呗，贼简单吧，就是双标签来设置范围吧)

     分析：这道题是获取所有 和为s的序列,  注意不是简单的获取数字，而是得到一个序列，序列内的数和为s
        【2】第二个就可以使用双指针，  这样不占用空间复杂度了，使用时的方法是：使用两个指针，和比s小，大指针后移【范围内数和增加】，比s大，小指针后移【范围内数和减小】 
'''
#这里  是输入数字s吧，   也不用列表，   然后对正整数
def sum_to_s(s):
    a,b=1,2
    ret=[]
    #这里a   的设置边界是   s/2，因为  a肯定小于b,而目标是a+b=s，所以  a如果 大于  s/2是 完全没有意义的
    while a<s/2+1:
        #达到目标判别条件     范围内 数值和打标
        if sum(range(a,b+1))==s:
            ret.append(range(a,b+1))
        #额外的两个移动条件
        elif sum(range(a,b+1))<s:
            b+=1
        else:
            a+=1
    return ret







